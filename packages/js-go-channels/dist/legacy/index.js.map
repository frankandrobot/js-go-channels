{"version":3,"sources":["../../src/index.js"],"names":["go","newChannel","close","select","range","initialStateFn","channels","dataProducers","dataConsumers","lastSelected","rangeRequests","state","cTakeRequest","cPutRequest","cCloseRequest","cSelectRequest","putCloseError","Error","dummyIterator","next","value","undefined","done","throw","return","_createConsumerMessage","consumer","message","chanId","consumerIterator","iterator","requestType","type","payload","selectedChanIds","i","indexOf","response","Array","length","_addConsumer","add","scheduler","generator","request","stopScheduler","nextTick","iteratorMessage","setTimeout","nextTickThrow","error","producer","pop","producerIterator","msg","lastSelectedId","__goId","chanData","unboundedLastSelected","last","_chanId","chanNum","channel","_id","take","_msgId","put","asyncPut","consumers","producers","map","x","forEach","callback","Object","assign","unsub"],"mappings":"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","file":"index.js","sourcesContent":["import {LinkedListBuffer, uuid, checkGenerator} from './utils'\n\n\nexport const initialStateFn = () => ({\n  /**\n   * map of active channels\n   */\n  channels: {},\n  dataProducers: {},\n  dataConsumers: {},\n  /**\n   * map of last selected channels\n   */\n  lastSelected: {},\n  /**\n   * array of range requests\n   */\n  rangeRequests: [],\n})\n\nconst state = initialStateFn()\n\nconst cTakeRequest = 'take'\nconst cPutRequest = 'put'\nconst cCloseRequest = 'close'\nconst cSelectRequest = 'select'\n\nconst putCloseError = new Error('Cannot put on a closed channel')\n\nconst dummyIterator = () => ({\n  next: () => ({value: undefined, done: true}),\n  throw: () => ({value: undefined, done: true}),\n  return: () => ({value: undefined, done: true}),\n})\n\n/**\n * Does what it says. Need to take into account the case when the\n * consumer is a pending select, pending take. `select`s have a\n * different signature.\n * @param {Object} consumer - the consumer and message that was queued\n * @param {Iterator} consumer.iterator\n * @param {string} consumer.type - the consumer's message type\n * @param {Object} consumer.payload - the consumer's message payload\n * @param {Object} message - the message to give to the consumer\n * @param {Object} extraArgs\n * @param {string} extraArgs.chanId\n * @returns {[Iterator, Message]}\n */\nfunction _createConsumerMessage(consumer, message, {chanId}) {\n  const {\n    iterator: consumerIterator,\n    type: requestType,\n    payload\n  } = consumer\n  if (requestType === cSelectRequest) {\n    const {selectedChanIds} = payload\n    const i = selectedChanIds.indexOf(chanId)\n    const response = new Array(selectedChanIds.length)\n    response[i] = message\n    return [consumerIterator, response]\n  } else if (requestType === cTakeRequest) {\n    return [consumerIterator, message]\n  }\n  throw new Error(`Unknown request type ${requestType}`)\n}\n\nfunction _addConsumer(\n  {\n    dataConsumers,\n    chanId,\n    consumer: {\n      iterator,\n      requestType,\n      payload,\n    },\n  },\n) {\n  dataConsumers[chanId].add({\n    iterator,\n    type: requestType,\n    payload,\n  })\n}\n\nfunction scheduler(\n  {\n    state: {\n      dataProducers,\n      dataConsumers,\n      channels,\n      lastSelected,\n    },\n    generator: {\n      iterator,\n      request,\n    },\n    stopScheduler\n  },\n) {\n  // Give the iterator the iteratorMessage and pass the result to the\n  // scheduler\n  const nextTick = (iterator, iteratorMessage) => {\n    const {\n      value: request,\n      done: stopScheduler,\n    } = iterator.next(iteratorMessage)\n    setTimeout(\n      () => scheduler({\n        state: {dataProducers, dataConsumers, channels, lastSelected},\n        generator: {\n          iterator,\n          request,\n        },\n        stopScheduler,\n      }),\n      0\n    )\n  }\n  // Give the iterator the error and pass the result to the scheduler\n  const nextTickThrow = (iterator, error) => {\n    const {\n      value: request,\n      done: stopScheduler,\n    } = iterator.throw(error)\n    setTimeout(\n      () => scheduler({\n        state: {dataProducers, dataConsumers, channels, lastSelected},\n        generator: {\n          iterator,\n          request,\n        },\n        stopScheduler,\n      }),\n      0\n    )\n  }\n  // if no request, then at start of generator, so get one\n  if (!request && !stopScheduler) {\n    return nextTick(iterator)\n  }\n  // if this generator is done, then goodbye\n  if (stopScheduler) {\n    return\n  }\n  const {type: requestType, chanId, payload} = request\n  switch(requestType) {\n  case cTakeRequest: {\n    // check if the channel is closed\n    if (!channels[chanId]) {\n      // if the channel is closed (buffer doesn't exist), then pass\n      // back undefined, done = true to the iterator.\n      return nextTick(iterator, {value: undefined, done: true})\n    }\n    // do we have any sleeping data producers?\n    const producer = dataProducers[chanId].pop()\n    if (producer) {\n      const {iterator: producerIterator, payload: {msg}} = producer\n      // give this iterator the msg\n      nextTick(iterator, {value: msg, done: false})\n      // also wake up the data producer\n      nextTick(producerIterator)\n    } else {\n      // add ourselves to the waiting list and hopefully we'll be\n      // woken up in the future\n      _addConsumer({\n        dataConsumers,\n        chanId,\n        consumer: {\n          iterator,\n          requestType,\n          payload,\n        },\n      })\n    }\n    return\n  }\n    // select returns the first data producer that fires. Sends back\n    // an array to the iterator. Just fire the first channel that\n    // receives a message: go thru the selected channels and try to\n    // get values. stop at the first that has a value.\n  case cSelectRequest: {\n    const {selectedChanIds} = payload\n    const lastSelectedId = `${iterator.__goId}:${selectedChanIds}`\n    let chanData = null\n    let producer = null\n    // mod by the number of selected channels so that we never get an\n    // out-of-bounds exception\n    const unboundedLastSelected =\n          typeof lastSelected[lastSelectedId] !== 'undefined'\n          ? lastSelected[lastSelectedId]\n          : -1\n    const last = (unboundedLastSelected + 1) % selectedChanIds.length\n    delete lastSelected[lastSelectedId]\n    // do we have any sleeping producers? but start from the last selected\n    for(let i=last; i<selectedChanIds.length; i++) {\n      const _chanId = selectedChanIds[i]\n      if (!channels[_chanId]) {\n        // if channel was closed then send undefined\n        chanData = {value: undefined, done: true, chanNum: i}\n        break\n      } \n      producer = dataProducers[_chanId].pop()\n      if (producer) {\n        const {payload: {msg}} = producer\n        chanData = {value: msg, done: false, chanNum: i}\n        break\n      }\n    }\n    if (chanData) {\n      // set last selected\n      lastSelected[lastSelectedId] = chanData.chanNum\n      // wake up the producer\n      producer && nextTick(producer.iterator)\n      const response = new Array(selectedChanIds.length)\n      response[chanData.chanNum] = {\n        value: chanData.value,\n        done: chanData.done\n      }\n      nextTick(iterator, response)\n    } else {\n      // There were no sleeping producers, so add ourselves to the\n      // waiting list of all the non-closed producers.\n      for(let i=0; i<selectedChanIds.length; i++) {\n        if (dataConsumers[selectedChanIds[i]]) {\n          _addConsumer({\n            dataConsumers,\n            chanId: selectedChanIds[i],\n            consumer: {\n              iterator,\n              requestType,\n              payload,\n            },\n          })\n        }\n      }\n    }\n    return\n  }\n  case cPutRequest: {\n    // First check if the channel is closed.\n    if (!channels[chanId]) {\n      nextTickThrow(iterator, putCloseError)\n      return\n    }\n    const {msg} = payload\n    // do we have any takers?\n    const consumer = dataConsumers[chanId].pop()\n    if (consumer) {\n      nextTick(iterator)\n      nextTick(..._createConsumerMessage(\n        consumer,\n        {value: msg, done: false},\n        {chanId}\n      ))\n    } else {\n      // let's wait for a data consumer\n      dataProducers[chanId].add({iterator, payload, type: requestType})\n    }\n    return\n  }\n  }\n}\n\nexport function go(generator) {\n  const iterator = checkGenerator(generator)\n  iterator.__goId = uuid()\n  // so `go` kicks off the scheduler\n  scheduler({\n    state,\n    generator: {\n      iterator,\n      request: undefined,\n      done: false,\n    }\n  })\n}\n\nexport function newChannel() {\n  const {channels, dataProducers, dataConsumers} = state\n  const chanId = uuid()\n  channels[chanId] = true\n  dataProducers[chanId] = new LinkedListBuffer()\n  dataConsumers[chanId] = new LinkedListBuffer()\n  const channel = {\n    get _id() {\n      return chanId\n    },\n    take(_msgId) {\n      return {\n        chanId,\n        type: cTakeRequest,\n        payload: {}\n      }\n    },\n    put(msg) {\n      return {\n        chanId,\n        type: cPutRequest,\n        payload: {msg},\n      }\n    },\n    asyncPut(msg) {\n      if (!channels[chanId]) {\n        throw putCloseError\n      }\n      scheduler({\n        state,\n        generator: {\n          // pass a dummyIterator. We don't care about any errors that\n          // may happen down the road, nor do we need any messages\n          // from the scheduler\n          iterator: dummyIterator(),\n          request: channel.put(msg)\n        },\n        stopScheduler: false\n      })\n    },\n  }\n  return channel\n}\n\nexport function close(channel, _msgId) {\n  const {channels, dataProducers, dataConsumers} = state\n  const chanId = channel._id\n  if (!channels[chanId]) {\n    throw new Error('Channel is already closed')\n  }\n  // turn off channel\n  delete channels[chanId]\n  // tell any pending consumers the channel is closed\n  const consumers = dataConsumers[chanId]\n  let consumer = consumers.pop()\n  while(consumer) {\n    const [iterator, request] = _createConsumerMessage(\n      consumer,\n      {value: undefined, done: true},\n      {chanId}\n    )\n    scheduler({\n      state,\n      generator: {\n        iterator,\n        request,\n      }\n    })\n    consumer = consumers.pop()\n  }\n  delete dataConsumers[chanId]\n  // hope we don't have pending producers\n  const producers = dataProducers[chanId]\n  let producer = producers.pop()\n  while(producer) {\n    const {iterator} = producer\n    const {\n      value: request,\n      done: stopScheduler,\n    } = iterator.throw(putCloseError)\n    scheduler({\n      state,\n      generator: {\n        iterator,\n        request,\n      },\n      stopScheduler,\n    })\n    producer = producers.pop()\n  }\n  delete dataProducers[chanId]\n  return\n}\n\nexport function select(...channels) {\n  return {\n    type: cSelectRequest,\n    payload: {selectedChanIds: channels.map(x => x._id) || []},\n  }\n}\n\nexport function range(channel) {\n  return {\n    // This actually registers the callback\n    forEach(callback) {\n        // Internally, it's an iterator\n      const iterator = Object.assign(\n        dummyIterator(),\n        {\n          next: ({value, done}) => {\n            if (done) {\n              // tell the scheduler we're done and don't update\n              // callback\n              return {value: undefined, done: true}\n            }\n            // pass the value to the callback\n            const unsub = callback(value)\n            if (unsub === false) {\n              // tell the scheduler we're done if callback requests to\n              // unsubscribe\n              return {value: undefined, done: true}\n            }\n            // tell the scheduler that the next request is for another\n            // take\n            return {value: channel.take(), done: false}\n          }\n        }\n      )\n      // queue self\n      scheduler({\n        state,\n        generator: {\n          iterator,\n          request: channel.take()\n        },\n        stopScheduler: false\n      })\n    }\n  }\n}\n"]}