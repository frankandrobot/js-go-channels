{"version":3,"sources":["../../src/index.js","../../src/utils.js"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["import {LinkedListBuffer, uuid, checkGenerator} from './utils'\n\n\nexport const initialStateFn = () => ({\n  /**\n   * map of active channels\n   */\n  channels: {},\n  dataProducers: {},\n  dataConsumers: {},\n  /**\n   * map of last selected channels\n   */\n  lastSelected: {},\n  /**\n   * array of range requests\n   */\n  rangeRequests: [],\n})\n\nconst state = initialStateFn()\n\nconst cTakeRequest = 'take'\nconst cPutRequest = 'put'\nconst cCloseRequest = 'close'\nconst cSelectRequest = 'select'\n\nconst putCloseError = new Error('Cannot put on a closed channel')\n\nconst dummyIterator = () => ({\n  next: () => ({value: undefined, done: true}),\n  throw: () => ({value: undefined, done: true}),\n  return: () => ({value: undefined, done: true}),\n})\n\n/**\n * Does what it says. Need to take into account the case when the\n * consumer is a pending select, pending take. `select`s have a\n * different signature.\n * @param {Iterator} consumer\n * @param {Object} message\n * @param {Object} extraArgs\n * @param {string} extraArgs.chanId\n */\nfunction _createConsumerMessage(consumer, message, {chanId}) {\n  const {\n    iterator: consumerIterator,\n    type: requestType,\n    payload\n  } = consumer\n  if (requestType === cSelectRequest) {\n    const {selectedChanIds} = payload\n    const i = selectedChanIds.indexOf(chanId)\n    const response = new Array(selectedChanIds.length)\n    response[i] = message\n    return [consumerIterator, response]\n  } else if (requestType === cTakeRequest) {\n    return [consumerIterator, message]\n  }\n  throw new Error(`Unknown request type ${requestType}`)\n}\n\nfunction _addConsumer(\n  {\n    dataConsumers,\n    chanId,\n    consumer: {\n      iterator,\n      requestType,\n      payload,\n    },\n  },\n) {\n  dataConsumers[chanId].add({\n    iterator,\n    type: requestType,\n    payload,\n  })\n}\n\nfunction scheduler(\n  {\n    state: {\n      dataProducers,\n      dataConsumers,\n      channels,\n      lastSelected,\n    },\n    generator: {\n      iterator,\n      request,\n    },\n    stopScheduler\n  },\n) {\n  // Give the iterator the iteratorMessage and pass the result to the\n  // scheduler\n  const nextTick = (iterator, iteratorMessage) => {\n    const {\n      value: request,\n      done: stopScheduler,\n    } = iterator.next(iteratorMessage)\n    setTimeout(\n      () => scheduler({\n        state: {dataProducers, dataConsumers, channels, lastSelected},\n        generator: {\n          iterator,\n          request,\n        },\n        stopScheduler,\n      }),\n      0\n    )\n  }\n  // Give the iterator the error and pass the result to the scheduler\n  const nextTickThrow = (iterator, error) => {\n    const {\n      value: request,\n      done: stopScheduler,\n    } = iterator.throw(error)\n    setTimeout(\n      () => scheduler({\n        state: {dataProducers, dataConsumers, channels, lastSelected},\n        generator: {\n          iterator,\n          request,\n        },\n        stopScheduler,\n      }),\n      0\n    )\n  }\n  // if no request, then at start of generator, so get one\n  if (!request && !stopScheduler) {\n    return nextTick(iterator)\n  }\n  // if this generator is done, then goodbye\n  if (stopScheduler) {\n    return\n  }\n  const {type: requestType, chanId, payload} = request\n  switch(requestType) {\n  case cTakeRequest: {\n    // check if the channel is closed\n    if (!channels[chanId]) {\n      // if the channel is closed (buffer doesn't exist), then pass\n      // back undefined, done = true to the iterator.\n      return nextTick(iterator, {value: undefined, done: true})\n    }\n    // do we have any sleeping data producers?\n    const producer = dataProducers[chanId].pop()\n    if (producer) {\n      const {iterator: producerIterator, payload: {msg}} = producer\n      // give this iterator the msg\n      nextTick(iterator, {value: msg, done: false})\n      // also wake up the data producer\n      nextTick(producerIterator)\n    } else {\n      // add ourselves to the waiting list and hopefully we'll be\n      // woken up in the future\n      _addConsumer({\n        dataConsumers,\n        chanId,\n        consumer: {\n          iterator,\n          requestType,\n          payload,\n        },\n      })\n    }\n    return\n  }\n    // select returns the first data producer that fires. Sends back\n    // an array to the iterator. Just fire the first channel that\n    // receives a message: go thru the selected channels and try to\n    // get values. stop at the first that has a value.\n  case cSelectRequest: {\n    const {selectedChanIds} = payload\n    const lastSelectedId = `${iterator.__goId}:${selectedChanIds}`\n    let chanData = null\n    let producer = null\n    // mod by the number of selected channels so that we never get an\n    // out-of-bounds exception\n    const unboundedLastSelected =\n          typeof lastSelected[lastSelectedId] !== 'undefined'\n          ? lastSelected[lastSelectedId]\n          : -1\n    const last = (unboundedLastSelected + 1) % selectedChanIds.length\n    delete lastSelected[lastSelectedId]\n    // do we have any sleeping producers? but start from the last selected\n    for(let i=last; i<selectedChanIds.length; i++) {\n      const _chanId = selectedChanIds[i]\n      if (!channels[_chanId]) {\n        // if channel was closed then send undefined\n        chanData = {value: undefined, done: true, chanNum: i}\n        break\n      } \n      producer = dataProducers[_chanId].pop()\n      if (producer) {\n        const {payload: {msg}} = producer\n        chanData = {value: msg, done: false, chanNum: i}\n        break\n      }\n    }\n    if (chanData) {\n      // set last selected\n      lastSelected[lastSelectedId] = chanData.chanNum\n      // wake up the producer\n      producer && nextTick(producer.iterator)\n      const response = new Array(selectedChanIds.length)\n      response[chanData.chanNum] = {\n        value: chanData.value,\n        done: chanData.done\n      }\n      nextTick(iterator, response)\n    } else {\n      // There were no sleeping producers, so add ourselves to the\n      // waiting list of all the non-closed producers.\n      for(let i=0; i<selectedChanIds.length; i++) {\n        if (dataConsumers[selectedChanIds[i]]) {\n          _addConsumer({\n            dataConsumers,\n            chanId: selectedChanIds[i],\n            consumer: {\n              iterator,\n              requestType,\n              payload,\n            },\n          })\n        }\n      }\n    }\n    return\n  }\n  case cPutRequest: {\n    // First check if the channel is closed.\n    if (!channels[chanId]) {\n      nextTickThrow(iterator, putCloseError)\n      return\n    }\n    const {msg} = payload\n    // do we have any takers?\n    const consumer = dataConsumers[chanId].pop()\n    if (consumer) {\n      nextTick(iterator)\n      nextTick(..._createConsumerMessage(\n        consumer,\n        {value: msg, done: false},\n        {chanId}\n      ))\n    } else {\n      // let's wait for a data consumer\n      dataProducers[chanId].add({iterator, payload, type: requestType})\n    }\n    return\n  }\n  case cCloseRequest: {\n    if (!channels[chanId]) {\n      nextTickThrow(iterator, new Error('Channel is already closed'))\n      return\n    }\n    // turn off channel\n    delete channels[chanId]\n    // tell any pending consumers the channel is closed\n    const consumers = dataConsumers[chanId]\n    let consumer = consumers.pop()\n    while(consumer) {\n      nextTick(..._createConsumerMessage(\n        consumer,\n        {value: undefined, done: true},\n        {chanId}\n      ))\n      consumer = consumers.pop()\n    }\n    delete dataConsumers[chanId]\n    // hope we don't have pending producers\n    const producers = dataProducers[chanId]\n    let producer = producers.pop()\n    while(producer) {\n      const {iterator: producerIterator} = producer\n      nextTickThrow(\n        producerIterator,\n        putCloseError)\n      producer = producers.pop()\n    }\n    delete dataProducers[chanId]\n    nextTick(iterator)\n    return\n  }\n  }\n}\n\nexport function go(generator) {\n  const iterator = checkGenerator(generator)\n  iterator.__goId = uuid()\n  // so `go` kicks off the scheduler\n  scheduler({\n    state,\n    generator: {\n      iterator,\n      request: undefined,\n      done: false,\n    }\n  })\n}\n\nexport function newChannel() {\n  const {channels, dataProducers, dataConsumers} = state\n  const chanId = uuid()\n  channels[chanId] = true\n  dataProducers[chanId] = new LinkedListBuffer()\n  dataConsumers[chanId] = new LinkedListBuffer()\n  const channel = {\n    get _id() {\n      return chanId\n    },\n    take(_msgId) {\n      return {\n        chanId,\n        type: cTakeRequest,\n        payload: {}\n      }\n    },\n    put(msg) {\n      return {\n        chanId,\n        type: cPutRequest,\n        payload: {msg},\n      }\n    },\n    asyncPut(msg) {\n      if (!channels[chanId]) {\n        throw putCloseError\n      }\n      scheduler({\n        state,\n        generator: {\n          // pass a dummyIterator. We don't care about any errors that\n          // may happen down the road, nor do we need any messages\n          // from the scheduler\n          iterator: dummyIterator(),\n          request: channel.put(msg)\n        },\n        stopScheduler: false\n      })\n    },\n  }\n  return channel\n}\n\nexport function close(channel, _msgId) {\n  return {\n    _msgId,\n    chanId: channel._id,\n    type: cCloseRequest,\n    payload: {},\n  }\n}\n\nexport function select(...channels) {\n  return {\n    type: cSelectRequest,\n    payload: {selectedChanIds: channels.map(x => x._id) || []},\n  }\n}\n\nexport function range(channel) {\n  return {\n    // This actually registers the callback\n    forEach(callback) {\n        // Internally, it's an iterator\n      const iterator = Object.assign(\n        dummyIterator(),\n        {\n          next: ({value, done}) => {\n            if (done) {\n              // tell the scheduler we're done and don't update\n              // callback\n              return {value: undefined, done: true}\n            }\n            // pass the value to the callback\n            const unsub = callback(value)\n            if (unsub === false) {\n              // tell the scheduler we're done if callback requests to\n              // unsubscribe\n              return {value: undefined, done: true}\n            }\n            // tell the scheduler that the next request is for another\n            // take\n            return {value: channel.take(), done: false}\n          }\n        }\n      )\n      // queue self\n      scheduler({\n        state,\n        generator: {\n          iterator,\n          request: channel.take()\n        },\n        stopScheduler: false\n      })\n    }\n  }\n}\n","export class BufferItem {\n  constructor(data, next) {\n    this.data = data\n    this.next = next\n  }\n}\n\nexport class LinkedListBuffer {\n  constructor() {\n    this.head = undefined\n    this.tail = undefined\n  }\n\n  add(item) {\n    const bufferItem = new BufferItem(item)\n    // first item ever\n    if (!this.head) {\n      this.head = bufferItem\n      this.tail = bufferItem\n      return\n    }\n    this.tail.next = bufferItem\n  }\n\n  pop() {\n    if(!this.head) {\n      return undefined\n    }\n    const item = this.head\n    this.head = this.head.next\n    return item.data\n  }\n}\n\n\nlet id = 0\n\nexport function  uuid() {\n  // Note that we're not using generators to avoid having generators\n  // as a libary dependency.\n  return id++\n}\n\n\nexport function checkGenerator(generator) {\n  // check if generator\n  if (!generator || typeof generator !== 'function' ) {\n    throw new Error('Need a generator');\n  }\n  const iterator = generator()\n  if (!iterator || typeof iterator[Symbol.iterator] !== 'function' ) {\n    throw new Error('Need an iterator');\n  }\n  return iterator\n}\n"]}